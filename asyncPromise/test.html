<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/>
    <title>Title</title>
</head>
<body>

<script>
    let p1 = new Promise((resolve, reject) => {
        resolve("p1的promise")//同步执行的
    })
    let p2 = p1.then(
        value => console.log(value),
        reason => console.log(reason)
    )
    console.log(p1)//因为执行了resolve那行代码所以变成了fulfilled的状态
    console.log(p2)//then产生了一个微任务(也是promise)，执行这个打印的时候，微任务还没执行，所以这个是pending状态，
    //但是在浏览器中查看p2，点开后是fulfilled状态，也是对的，因为点开之前微任务已经执行了

    // setTimeout(() => {
    //     //忽略上面的打印，执行下面两个打印的时候，then产生的微任务已经执行了，所以p2变成了fulfilled
    //     console.log(p1)
    //     console.log(p2)
    // })

    new Promise((resolve, reject) => {
        resolve("fulfilled")
    }).then(value => {//这里返回的如果是个对象且对象里有then方法，那对象就会被系统封装成一个Promise
        return {//这里的效果和下面直接返回一个Promise的效果是一样的
            then(onfulfilled, onrejected) {
                onfulfilled("返回成功")
            }
        }

        // return new Promise((resolve, reject) => {
        //     resolve("返回成功1")
        // })

    }, reason => {
    }).then(value => {
        console.log(value)//输出返回成功
    },reason => {})

    let obj = {a:1}
    console.log(obj)//浏览器打卡之后，没有点开之前显示是1,点开之后显示是2--这个没有错，我们当前想看到当时打印的值，但是打印结束后值确实发生了变化
    obj.a = 2
    console.log(obj)
</script>
</body>
</html>
